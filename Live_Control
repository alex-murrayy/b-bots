// ===== YOUR PIN MAP =====
const int PIN_FWD   = 5;  // Orange (Fwd)
const int PIN_REV   = 7;  // Grey BM (Rev)
const int PIN_LEFT  = 8;  // Purple FM (Left)
const int PIN_RIGHT = 6;  // Grey FM (Right)

// ===== BEHAVIOR SWITCHES =====
bool ACTIVE_LOW = false;          // set true if ON = LOW on your board
bool USE_BRAKE_BEFORE_REV = false; // set true only if reverse needs a brake pulse

// Steering tap length (ms)
int steerPulse = 200;

// ---------------- Internals ----------------
bool testMode = false;

int ON()  { return ACTIVE_LOW ? LOW  : HIGH; }
int OFF() { return ACTIVE_LOW ? HIGH : LOW; }

void allOff() {
  digitalWrite(PIN_FWD,   OFF());
  digitalWrite(PIN_REV,   OFF());
  digitalWrite(PIN_LEFT,  OFF());
  digitalWrite(PIN_RIGHT, OFF());
}

void neutralDrive() {
  digitalWrite(PIN_FWD, OFF());
  digitalWrite(PIN_REV, OFF());
}

void steerLeftTap() {
  digitalWrite(PIN_LEFT, ON());
  delay(steerPulse);
  digitalWrite(PIN_LEFT, OFF());
}

void steerRightTap() {
  digitalWrite(PIN_RIGHT, ON());
  delay(steerPulse);
  digitalWrite(PIN_RIGHT, OFF());
}

void engageForward() {
  neutralDrive();
  delay(100);
  digitalWrite(PIN_FWD, ON());
}

void engageReverse() {
  if (USE_BRAKE_BEFORE_REV) {
    neutralDrive();
    delay(80);
    digitalWrite(PIN_FWD, ON());  delay(150); // short brake
    digitalWrite(PIN_FWD, OFF()); delay(200); // neutral gap
  }
  digitalWrite(PIN_REV, ON());
}

void printHelp() {
  Serial.println(F("Normal: W=Fwd  S=Rev  A=LeftTap  D=RightTap  Space=stop  C=center  X=all stop"));
  Serial.println(F("Test mode: press 't' -> 1=FWD  2=REV  3=LEFT  4=RIGHT  x=all off  q=quit"));
  Serial.println(F("Hints: set ACTIVE_LOW=true if pins act inverted; enable USE_BRAKE_BEFORE_REV if S only works after a brake blip."));
}

void setup() {
  pinMode(PIN_FWD, OUTPUT);
  pinMode(PIN_REV, OUTPUT);
  pinMode(PIN_LEFT, OUTPUT);
  pinMode(PIN_RIGHT, OUTPUT);
  allOff();

  Serial.begin(9600);
  delay(100);
  Serial.println(F("WASD + Test Mode Ready"));
  printHelp();
}

void handleTestMode(char c) {
  switch (c) {
    case '1': allOff(); digitalWrite(PIN_FWD,   ON());  Serial.println("TEST: FWD ON");   break;
    case '2': allOff(); digitalWrite(PIN_REV,   ON());  Serial.println("TEST: REV ON");   break;
    case '3': allOff(); digitalWrite(PIN_LEFT,  ON());  Serial.println("TEST: LEFT ON");  break;
    case '4': allOff(); digitalWrite(PIN_RIGHT, ON());  Serial.println("TEST: RIGHT ON"); break;
    case 'x': allOff(); Serial.println("TEST: ALL OFF"); break;
    case 'q': allOff(); testMode=false; Serial.println("Exit TEST mode"); break;
    default: break;
  }
}

void loop() {
  if (!Serial.available()) return;
  char c = Serial.read();

  if (c=='t' || c=='T') { testMode = true; Serial.println("ENTER TEST MODE"); return; }
  if (testMode) { handleTestMode(c); return; }

  // Normal mode:
  // Drive is latched, steering is momentary (auto-center)
  switch (c) {
    case 'w': case 'W':
      engageForward();
      Serial.println("FWD");
      break;

    case 's': case 'S':
      engageReverse();
      Serial.println("REV");
      break;

    case 'a': case 'A':
      // center first
      digitalWrite(PIN_LEFT, OFF());
      digitalWrite(PIN_RIGHT, OFF());
      steerLeftTap();
      Serial.println("LEFT TAP");
      break;

    case 'd': case 'D':
      digitalWrite(PIN_LEFT, OFF());
      digitalWrite(PIN_RIGHT, OFF());
      steerRightTap();
      Serial.println("RIGHT TAP");
      break;

    case ' ': // stop drive
      neutralDrive();
      Serial.println("NEUTRAL DRIVE");
      break;

    case 'c': case 'C': // center steering
      digitalWrite(PIN_LEFT, OFF());
      digitalWrite(PIN_RIGHT, OFF());
      Serial.println("CENTER");
      break;

    case 'x': case 'X': // everything off
      allOff();
      Serial.println("ALL OFF");
      break;

    default: break;
  }
}
